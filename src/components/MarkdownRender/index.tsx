import { Button, Checkbox, Chip, Code, Divider, Image, Tooltip } from '@nextui-org/react';
import c from 'constant';
import React, { LegacyRef, useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';
import rehypePrism from 'rehype-prism-plus';
import rehypeRaw from 'rehype-raw';
import remarkGfm from 'remark-gfm';
import remarkToc from 'remark-toc';
import { twMerge } from 'tailwind-merge';

import Icon from 'components/Icons';
import Link from 'components/Link';

import { State } from 'types/Common';

interface MarkdownRenderProps {
  children: string;
  isComments?: boolean;
  classNames?: {
    wrapper?: string;
    content?: string;
  };
}

type Components = Partial<{
  [TagName in keyof JSX.IntrinsicElements]:  // Class component:
    | (new (props: JSX.IntrinsicElements[TagName]) => JSX.ElementClass)
    // Function component:
    | ((props: JSX.IntrinsicElements[TagName]) => JSX.Element | string | null | undefined)
    // Tag name:
    | keyof JSX.IntrinsicElements;
}>;
const customComponents: Components = {
  h1: (props) => {
    return (
      <CustomHeaderComponent
        as='h1'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  h2: (props) => {
    return (
      <CustomHeaderComponent
        as='h2'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  h3: (props) => {
    return (
      <CustomHeaderComponent
        as='h3'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  h4: (props) => {
    return (
      <CustomHeaderComponent
        as='h4'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  h5: (props) => {
    return (
      <CustomHeaderComponent
        as='h5'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  h6: (props) => {
    return (
      <CustomHeaderComponent
        as='h6'
        {...props}
      >
        {props.children}
      </CustomHeaderComponent>
    );
  },
  img: (props) => {
    return <CustomImageComponent {...props} />;

    const { src, alt } = props;
    return (
      <Tooltip content={'Click to open image in new tab'}>
        <span className='flex h-fit w-fit flex-col gap-2'>
          <Image
            src={src}
            alt={alt}
            className='cursor-pointer'
            classNames={{
              img: 'max-w-[32rem] max-h-[32rem] object-contain',
            }}
            removeWrapper
            onClick={() => window.open(src, '_blank')}
            onError={() => {}}
          />
          <span className='text-tiny capitalize text-default-400'>{alt}</span>
        </span>
      </Tooltip>
    );
  },
  a: (props) => {
    const { href, target, children } = props;
    const currentPath = window.location.pathname;
    const safeHref = href?.startsWith('/')
      ? href
      : href?.startsWith('#')
      ? `${window.location.pathname}${href}`
      : `/redirect?url=${encodeURIComponent(href as string)}&ref=${encodeURIComponent(currentPath)}`;

    return (
      <Link
        href={safeHref}
        isExternal={target === '_blank'}
      >
        {children || href}
      </Link>
    );
  },
  pre: (props) => {
    const { className, children } = props;

    const lang = className
      ?.split(' ')
      .find((c) => c.startsWith('language-'))
      ?.replace('language-', '');

    return (
      <CustomPreComponent
        language={lang}
        className={twMerge(className)}
      >
        {children}
      </CustomPreComponent>
    );
  },
  code: (props) => {
    const { className, children } = props;

    if (typeof children === 'string') {
      return (
        <Code
          size='sm'
          className='border border-divider bg-content1 shadow-medium'
        >
          {children}
        </Code>
      );
    } else {
      return <code className={twMerge(className)}>{children}</code>;
    }
  },
  p: (props) => {
    const { children } = props;
    if (!children) {
      return (
        <div
          id='comment-prohibited-identifier'
          className='paragraph flex flex-col flex-wrap rounded-medium border-medium border-divider bg-background/25 p-2 text-small text-danger'
        >
          <span>This comment contains prohibited content and cannot be displayed.</span>
          <span>This comment will be deleted as soon as possible.</span>
          <Divider className='my-2' />
          <span className='text-foreground'>This comment is automatically generated by the system.</span>
        </div>
      );
    }
    return <div className='paragraph'>{children}</div>;
  },
  input: (props) => {
    const { type, ...rest } = props;

    switch (type) {
      case 'checkbox':
        return (
          <Checkbox
            isSelected={props.checked}
            isReadOnly
            lineThrough
          />
        );
      default:
        return (
          <input
            type={type}
            {...rest}
          />
        );
    }
  },
  table: (props) => {
    return (
      <div className='relative z-0 my-4 flex w-full flex-col justify-between gap-4 overflow-auto rounded-large bg-content1 p-4 shadow-small'>
        <table className={props.className}>{props.children}</table>
      </div>
    );
  },
  blockquote: (props) => {
    return <CustomBlockquoteComponent {...props}>{props.children}</CustomBlockquoteComponent>;
  },
};

export default function MarkdownRender({ children, isComments, classNames }: MarkdownRenderProps) {
  return (
    <div className={twMerge('w-full', isComments ? 'markdown-comment' : 'markdown', classNames?.wrapper)}>
      <ReactMarkdown
        remarkPlugins={[remarkGfm, remarkToc]}
        rehypePlugins={[rehypeRaw, [rehypePrism, { ignoreMissing: true }]]}
        allowedElements={
          isComments ? ['p', 'code', 'a', 'pre', 'span', 'b', 'strong', 'em', 'del', 'blockquote'] : undefined
        }
        className={twMerge('w-full', classNames?.content)}
        components={customComponents}
      >
        {children}
      </ReactMarkdown>
    </div>
  );
}

MarkdownRender.defaultProps = {
  isComments: false,
};

interface PreProps extends React.HTMLAttributes<HTMLPreElement> {
  language?: string;
}
function CustomPreComponent(props: PreProps) {
  const codeRef = useRef<HTMLPreElement>();
  const [copyStatus, setCopyStatus] = useState<State>('idle');

  useEffect(() => {
    if (!codeRef.current) return;
    if (copyStatus !== 'idle') {
      const timeout = setTimeout(() => {
        setCopyStatus('idle');
      }, 3000);

      return () => clearTimeout(timeout);
    }
  }, [copyStatus]);

  return (
    <span className='relative'>
      <span className='absolute right-0 top-2 flex w-full items-center justify-end gap-2 rounded-medium p-2'>
        <Chip
          size='sm'
          color='secondary'
          classNames={{
            content: 'uppercase',
          }}
        >
          {props.language ?? 'Unknown language'}
        </Chip>
        <Button
          size='sm'
          variant='light'
          color={copyStatus === 'success' ? 'success' : copyStatus === 'error' ? 'danger' : 'default'}
          isIconOnly
          onPress={() => {
            if (!codeRef.current) return;
            if (copyStatus !== 'idle') return;

            try {
              navigator.clipboard.writeText(codeRef.current.textContent as string);
              setCopyStatus('success');
            } catch (error: any) {
              console.error(error);
              setCopyStatus('error');
            }
          }}
        >
          <Icon
            name={copyStatus === 'success' ? 'Check' : copyStatus === 'error' ? 'X' : 'Copy'}
            size='sm'
          />
        </Button>
      </span>
      <pre
        ref={codeRef as LegacyRef<HTMLPreElement>}
        className={twMerge(
          'code h-full max-h-[60vh] !rounded-medium border border-divider shadow-medium',
          props.className,
        )}
      >
        {props.children}
      </pre>
    </span>
  );
}
interface HeadProps extends React.HTMLAttributes<HTMLHeadingElement> {
  as: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
}
function CustomHeaderComponent(props: HeadProps) {
  const { as, ...rest } = props;
  const Render = as;
  const headingRef = useRef<HTMLHeadingElement>();
  const [id, setId] = useState<string | undefined>(props.id);

  useEffect(() => {
    if (!headingRef.current) return;
    // id = textContent to lowercase, replace all spaces with dash, and remove all symbols
    const formattedId = headingRef.current.textContent
      ?.toLowerCase()
      .replace(/\s/g, '-')
      .replace(/[^\w-]+/g, '');
    if (formattedId) setId(formattedId);
  }, []);

  return (
    <Render
      id={id}
      ref={headingRef as LegacyRef<HTMLHeadingElement>}
      {...rest}
    >
      {props.children}
    </Render>
  );
}

function CustomBlockquoteComponent(props: React.HTMLAttributes<HTMLQuoteElement>) {
  const quoteRef = useRef<HTMLQuoteElement>();
  const [isClamped, setIsClamped] = useState(false);
  useEffect(() => {
    if (!quoteRef.current) return;

    const content = quoteRef.current.textContent;
    const lineLength = content?.split('\n').filter((line) => line.trim().length > 0).length ?? 0;
    if (lineLength > 4) setIsClamped(true);
  }, []);

  return (
    <div className='relative'>
      <blockquote
        ref={quoteRef as LegacyRef<HTMLQuoteElement>}
        className={twMerge('', props.className)}
        {...props}
      >
        {props.children}
      </blockquote>
      {isClamped && (
        <>
          <div className='absolute bottom-0 right-0 flex h-full w-full items-center justify-center rounded-medium bg-gradient-to-t from-background to-transparent' />
          <span className='absolute bottom-2 w-full text-center text-tiny'>
            Click the name above to see the full comment
          </span>
        </>
      )}
    </div>
  );
}

function CustomImageComponent(
  props: React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>,
) {
  const { src, alt } = props;
  const [imgSrc, setImgSrc] = useState(src as string);
  return (
    <Tooltip content={'Click to open image in new tab'}>
      <span className='flex h-fit w-fit flex-col gap-2'>
        <Image
          src={imgSrc}
          alt={alt}
          className='cursor-pointer'
          classNames={{
            img: 'max-w-[32rem] max-h-[32rem] object-contain',
          }}
          removeWrapper
          onClick={() => window.open(src, '_blank')}
          onError={() => {
            setImgSrc(c.PLACEHOLDER_IMAGE);
          }}
        />
        <span className='text-tiny capitalize text-default-400'>{alt}</span>
      </span>
    </Tooltip>
  );
}
